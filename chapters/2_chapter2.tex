% 第二章

\chapter{Linux上的网络通信}

虽然互联网如今无处不在，但网络通信、网卡和网络驱动程序仍然经常被开发人员和用户视为黑箱。对于用户来说，大多数时候，他们只需要将网线插入电脑就可以上网了。对于开发人员来说，操作系统提供的高级API让他们可以轻松地在其程序中包含网络通信功能，而无需处理低级网络编程的复杂性。

然而，如果还没有为某种网卡提供驱动程序，或者当报文处理性能成为一个重要考虑因素时，有必要对网络通信的基础知识，尤其是应用程序与操作系统和网卡交互的方式，有初步的了解。每次从应用程序发送数据时，数据都会经过几层处理，直到到达网卡。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.5\textwidth]{images/figure2-1.eps}
    \caption{OSI参考模型中的通信层次}\label{fig:OSI-layers} % label 用来在文中索引
\end{figure}

一个好的模型——也是事实上的标准——是OSI参考模型，OSI模型描述了这些层次（layers），它的结构如图\ref{fig:OSI-layers}所示。

模型中的每一层都为上层提供不同的服务，如数据包分割（第4层）、路由（第3层）或可靠传输（第2层）。

通常，应用程序负责应用层、表示层和会话层，而传输层和网络层则由操作系统通过通用内核网络堆栈进行处理。最低的两层，物理层和数据链路层，由网络接口卡（NIC）和网络驱动程序控制。

由于Linux操作系统的设计，传统上，网络应用程序和网络驱动程序的不同任务在Linux中被用户空间和内核空间分隔开。然而，Linux中有不同的低级数据包处理方法：大多数应用程序使用内核的套接字API，而一些应用程序运行自己的内核模块，一些在内核空间中处理所有内容，一些在用户空间中处理所有内容。

\section{内核空间}

Linux是基于宏内核的操作系统，这意味着整个操作系统都在内核空间中运行，而其他所有服务都在用户空间中运行。内核为用户空间应用程序提供套接字API，即各种函数和数据类型，用于在所谓的\textit{Berkeley}或\textit{POSIX}套接字上提供易于使用的接口。这些套接字是特殊文件，可以通过简单的读写操作与本地进程或远程主机进行通信，遵循Unix的“一切都是文件”的概念。希望建立通信通道的用户空间应用程序会调用\verb|socket()|函数，该函数最终会在内核中创建一个套接字结构实例，并向应用程序返回该套接字的文件描述符。随后，\verb|bind()|和\verb|connect()|或\verb|listen()|和\verb|accept()|将两个或多个进程之间的连接与套接字关联起来，\verb|send()|和\verb|recv()|则用于向套接字发送和接收数据。

为了减小通用内核堆栈的问题，一些应用实现了它们自己的内核模块。对于这种方式，两个著名的例子是Open vSwitch\cite{pfaff2015design}和Click Modular Router\cite{kohler2000click}。

